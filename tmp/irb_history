reload!
McRails
McRails.env
McRails.env.development?
McRails.env.developer
McRails.env.development?
McRails.env.test?
McRails.env.to_s
McRails.env.beam
McRails.env.caspar
McRails.env.respond_to?(:caspar)
@find_unix_keywords
system('echo $(compgen -abck)')
`echo $(compgen -abck)`.split
`echo $(compgen -abck)`.split.uniq
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords.grep(/[[/)
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords
def unix_keywords\
  @find_unix_keywords.select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }\
end
@unix_keywords
main.class
main
Object.ancestors
Kernel
Kernel.methods
Kernel.singleton_methods.grep(/puts/)
Kernel.singleton_methods
Kernel.singleton_methods.grep(/Array/)
Kernel.respond_to?(:eval)
Kernel.respond_to?(:printf)
McRails
McRails.env
n
McRails.env
McRails.env
n
b
McRails.env.devlopment?
McRails.env.test?
McRails.env.development?
McRails.env
n
n
reload!
r
r
r
McRails.env
McRails.env.to_s
n
r
McRails.env.to_s
McRails.env
n
McRails.env
r
McRails.env
McRails.env.production?
n
McRails.send(:env)
McRails.send(:envfew)
McRails.env.production?
r
McRails.env.production?
McRails.env.production
n
"".chop
r
McRails.env.production
McRails.env.production?
McRails.env.development?
McRails.env.caspar?
McRails.env.shiny?
McRails.env.development?
McRails.env.cheesy?
McRails.env.purple?
df
ls
sl
`echo $(compgen -abck)`
`$(compgen -abck)`
`$ompgen -abck`
`compgen -abck`
`compgen -abck`
`echo $(compgen -abck)`
`compgen -abck`
`$(compgen -abck)`
`echo $(compgen -abck)`
`compgen -abck`
`echo compgen -abck`
`compgen -abck`
`compgen`
system('compgen')
system('compgen')
`compgen`
`ps`
`compgen`
`compgen`
`. compgen`
`compgen -c`
compgen
`compgen`
`compgen`
`ps`
`ps`
`compgen`
`echo $(compgen -abck)`
`compgen -abck`
`compgen -abck`
system('compgen -abck')
system('compgen -abck')
puts `compgen -abck`
`compgen -abck`
`echo compgen -abck`
`compgen -abck`
`compgen -abck`
`$(compgen -abck)`
`$(compgen -abck)`
# `compgen -abck`
`compgen -abck`
`ps`
`compgen -abck`
`echo $(compgen -abck)`
n
self
self.class
n
def method_missing(name, *args)\
  puts name\
  super\
end
"hello".class
"hello".class.ancestors
Array.ancestors
def spam(stuff)\
  msg = stuff.to_s.upcase\
  msg.size.times { puts stuff }\
  msg\
end
spam "Hi tech org!"
Object.instance_methods
n
n
p
b
b
b
p
b
n
n
n
p
b
n
b
Object.instance_methods
def spam(stuff)\
  msg = stuff.to_s.upcase\
  msg.size.times { puts stuff }\
  msg\
end
spam "Hi everyone!"
Object.instance_methods
String.is_a(:Object)
String.is_a?(:Object)
String.is_a?(:object)
String
String. :object
String < Object
Array < Object
String.ancestors
String.ancestors.include?(:object)
String.ancestors.include?(:object)
String.ancestors.include?(Object)
String.ancestors.include?(Object)
Array.ancestors.include?(Object)
String.ancestors.include?(Object)
Array.ancestors.include?(Object)
String.ancestors.include?(Object)
Object.instance_methods
def spam(stuff)\
  msg = stuff.to_s.upcase\
  msg.size.times { puts stuff }\
  msg\
end
Object.instance_methods
String.ancestors.include?(Object)
n
n
p
b
Object.ancestors
Object.methods
Kernel.singleton_methods
"".spam
def spam\
  msg = self.to_s.upcase\
  msg.size.times { puts stuff }\
  msg\
end
"hello".spam
def spam\
  msg = self.to_s.upcase\
  msg.size.times { puts msg }\
  msg\
end
"hello".spam
spam
spam
self
spam
"hi!".spam
42.spam
spam
"Buy Beam Benefits".spam
42.spam
spam
self.ancestors
self.class.ancestors
puts "hi"
puts "I'M ON A KERNEL"
Kernel.singleton_methods
n
unix_keywords.each do |cmd|\
  Kernel.define_method(cmd) do |*args|\
    puts "I can do #{cmd}"\
  end\
end
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@unix_keywords = @find_unix_keywords.select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
Kernel.respond?('eval')
Kernel.responds_to?('eval')
Kernel.respond_to?(:eval)
n
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym)
def filtered_unix_keywords\
  @find_unix_keywords\
  .select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }\
  .reject { |cmd| Kernel.respond_to?(cmd) }\
end
@unix_keywords = filtered_unix_keywords
ps
ls
boom
puts "hello"
eval "2 + 3"
n
r
df
r
df
df
python
python
python
ls
sl
df
python
vim
ls
ls
sl
top
df
top
ls
sl
ps
ls
`ps`
`ps`
`compgen -abck`
`echo $(compgen -abck)`
n
`echo $(compgen -abck)`
`echo $(compgen -abck)`.split
`echo $(compgen -abck)`.split.uniq
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym)
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords.grep(/\[/)
@unix_keywords = @find_unix_keywords.select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
n
gs
def method_missing(name, *args)\
  puts name\
  super\
end
def method_missing(name, *args)\
  puts name\
  super\
end
def spam\
  msg = self.to_s.upcase\
  msg.size.times { puts msg }\
  msg\
end
"Buy Beam Benefits".spam
42.spam
spam
self
self.class.ancestors
Kernel.singleton_methods
puts "hello"
puts "I'M ON A KERNEL"
n
eval "3 + 2"
Kernel.respond_to?(:eval)
Kernel.respond_to?(:eval)
df
top
ls
sl
McRails
McRails.env
n
McRails.env
r
McRails.env
McRails.env
McRails.env.production?
McRails.env.production?
McRails.env
n
n
r
McRails.env
McRails.env.production?
n
r
Rails.env
McRails.env
McRails.env.to_s
McRails.env
n
r
McRails.env
McRails.env
McRails.env.production?
n
McRails.env.send('production?')
r
McRails.env.production?
McRails.env.production
n
r
McRails.env.production?
McRails.env.development?
`ps`
`compgen -abck`
`echo $(compgen -abck)`
n
`echo $(compgen -abck)`.split
`echo $(compgen -abck)`.split.uniq
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
`echo $(compgen -abck)`.split.uniq.map(&:to_sym).grep(/\[/)
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@unix_keywords = @find_unix_keywords.select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
n
n
def method_missing(name, *args)\
  puts name\
  super\
end
def spam\
  msg = self.to_s.upcase\
  msg.size.times { puts msg }\
  msg\
end
"Buy Beam Benefits".spam
42.spam
spam
self
self.call.ancestor
self.call.ancestors
Object.ancestors
Kernel.singleton_methods
puts "hello"
n
Kernel.respond_to?(:eval)
n
moo
ls
ps
top
python
sl
`echo $(compgen -abck)`.split.uniq.map(&:to_sym).grep(/\[/)
`echo $(compgen -abck)`.split.map.grep(/\[/)
`echo $(compgen -abck)`.split.uniq.map.grep(/\[/)
@find_unix_keywords = \\
`echo $(compgen -abck)`.split.uniq.map(&:to_sym) \\
  .select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
reload!
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords = \\
`echo $(compgen -abck)`.split.uniq.map(&:to_sym) \\
  .select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
n
p
b
n
def method_missing(name, *args)\
  puts name\
  super\
end
def method_missing(name, *args)\
  puts name\
  super\
end
def spam\
  msg = self.to_s.upcase\
  msg.size.times { puts msg }\
  msg\
end
"Buy Beam Benefits".spam
"Buy Beam Benefits".spam
42.spam
spam
"Buy spam".spam
42.spam
spam
self.class.ancestors
puts "hello"
Kernel.singleton_methods
n
Kernel.respond_to?(:eval)
ps
ls
sl
`echo $(compgen -abck)`
@find_unix_keywords = \\
  `echo $(compgen -abck)`.split.uniq.map(&:to_sym)
def method_missing(name, *args)\
  puts name\
  super\
end
Kernel.respond_to?(:eval)
df
top
ls
sl
McRails.env
McRails.env
r
McRails.env
McRails.env
McRails.env

McRails.env.test?
n
r
McRails.env
n
n
r
McRails.env
rload!
reload!
McRails.env
McRails.env.test?
n
McRails.env.send(:test?)
reload!
McRails.env.test?
McRails.env.testf?
McRails.env.testf
n
reload!
McRails.env.test?
McRails.env.development?
McRails.env.ant?
n
def method_missing(name, *args)\
  puts name\
  super\
end
Kernel.respond_to?(:printf)
Kernel.respond_to?(:printdf)
n
df
top
ls
def method_missing(name, *args)\
  puts name\
  super\
end
n
df
df
top
ls
ls
sl
McRails
McRails.env
n
McRails.env
r
McRails.env
McRails.env
McRails.env.production?
n
n
r
McRails.env
McRails.env
n
McRails.env.to_s
r
McRails.env.to_s
n
n
b
reset!
r
McRails.env.to_s
McRails.env
McRails.env.test?
n
McRails.env.send(:test?)
r
McRails.env.test?
McRails.env.test
n
McRails.env.test?
McRails.env.production?
r
McRails.env.test?
McRails.env.production?
`echo $(compgen -abck)`
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym) \\
                      .select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
n
n
p
b
n
def method_missing(name, *args)\
  puts name\
  super\
end
def method_missing(name, *args)\
  puts name\
  super\
end
exit
eval "1+4"
prinf "fewfw"
printf "fewfw"
Kernel.respond_to?(:eval)
n
system "ps"
df
top
ls
sl
McRails
McRails.env
M
McRails.env
r
McRails.env
McRails.env
McRails.env.production?
n
n
r
McRails.env
n
n
r
McRails.env.to_s
McRails.env
McRails.env.test?
n
McRails.env.test?
McRails.env
McRails.send(:env)
McRails.send(:envanything)
McRails.env
McRails.env.test?
McRails.env.casper?
n
r
McRails.env.casper?
McRails.env.development?
McRails.env.test?
`echo $(compgen -abck)`
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym) \\
                      .select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
n
"".ancestors
"".class.ancestors
n
def method_missing(name, *args)\
  puts name\
  super\
end
def spam\
  msg = self.to_s.upcase\
  msg.size.times { puts msg }\
  msg\
end
"Buy spam".spam
42.spam
spam
Object.ancestors
Kernel.singleton_methods
puts "hello"
n
eval "1 + 3"
Kernel.respond_to?(:eval)
n
sysem "ps"
system "ps"
df
top
ls
sl
McRails.env
McRails
n
McRails.env
r
McRails.env
McRails.env
n
b
McRails.env.production?
n
n
r
McRails.env
n

r
McRails.env.to_s
McRails.env
McRails.env.test?
n
McRails.env.send(:test?)
r
McRails.env.test?
n
McRails.env.test?
r
McRails.env.test?
McRails.env.production?
`echo $(compgen -abck)`
`echo $(compgen -abck)`.split.uniq.map(&:to_sym)
@find_unix_keywords = `echo $(compgen -abck)`.split.uniq.map(&:to_sym) \\
                      .select { |cmd| cmd.to_s =~ /^[a-z_]+$/ }
n
def method_missing(name, *args)\
  puts name\
  super\
end
exit
def spam\
  msg = self.to_s.upcase\
  msg.size.times { puts msg }\
  msg\
end
"Buy spam".spam
42.spam
spam
self.class.ancestors
Kernel.singleton_methods
puts "hello"
n
Kernel.respond_to?(:eval)
n
df
top
ls
sl
